
\section{A Linear Greedy Variant of First-Order \LowerUnits}
\label{sec:SimpleFOLU}

The {\FOLowerUnits} described in the previous section is not only complex (worst-case quadratic run-time complexity in the length of the input proof) but also difficult to implement. The necessity to ensure the post-deletion unifiability property would require a lot of bookkeeping, to track changes in literals and their descendants, and to know which literals have to be contracted in the bottom of the proof before reintroduction of the units. 

This section presents {\SFOLowerUnits} (Algorithm \ref{algo:optSFOLU}), an alterantive (single traversal) variant of {\FOLowerUnits}, which avoids the quadratic complexity and the implementation difficulties by: 1) ignoring the stricter post-deletion unifiability property and focusing instead on the pre-deletion unifiability property, which is easier to check (lines 9-11); and 2) employing a greedy contraction approach (lines 16-18) together with substitutions (lines 5-7), in order not to care about bookkeeping. By doing so, compression may not always succeed on all proofs (e.g. Example \ref{ex:rootpair}). When compression succeeds, the root clause of the generated proof will be the empty clause (line 20) and the generated proof may be returned. Otherwise, the original proof must be returned (line 20).


\begin{algorithm}[pbt]
  \SetAlgoVlined
  \SetAlgoShortEnd
  \SetKwData{Units}{Units}

  \KwIn {a proof $\psi$}
  \KwOut {a compressed proof $\psi^{\star}$}
  \KwData{a map $.'$, eventually mapping any $\varphi$ to \Del{$\varphi$, \Units}}
  \BlankLine

  \SetKw{Push}{push}
  \SetKw{Pop} {pop}
  \SetKw{Add} {add}
  \SetKw{Rep} {replace}

  \algolines{$D \leftarrow \varnothing$}{set for storing subproofs that need to be deleted}
  \algolines{\Units $\leftarrow \varnothing$}{stack for storing collected units}
  \BlankLine

  \For{every subproof $\varphi$, in a top-down traversal of $\psi$ }{

    \lIf{$\varphi$ is an axiom}{$\varphi' \leftarrow \varphi$}
    \ElseIf{$\varphi = \varphi_L \res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R} \varphi_R$}{
      \lIf{ $\varphi_L \in D$ and $\varphi_R \in D$}{
        \Add $\varphi$ to $D$
      }
      \lElseIf{$\varphi_L \in D$}{
          $\varphi' \leftarrow \con{\varphi'_R}{}{\sigma_R}$
      }
      \lElseIf{ $\varphi_R \in D$ }{
          $\varphi' \leftarrow \con{\varphi'_L}{}{\sigma_L}$
      }

      \BlankLine

      \lElseIf{$\ell \notin \Conclusion{\varphi'_L}$}{ 
        $\varphi' \leftarrow \con{\varphi'_L}{}{\sigma_L}$ 
      }
      \lElseIf{$\dual{\ell} \notin \Conclusion{\varphi'_R}$}{ 
        $\varphi' \leftarrow \con{\varphi'_R}{}{\sigma_R}$  
      }
    
      \lElse{ $\varphi' \leftarrow \varphi'_L \res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R} \varphi'_R$ }

        
    }
    \lElseIf{$\varphi = \con{\varphi_c}{ \{\ell_1,\ldots,\ell_n \} }{\sigma}$}{
      $\varphi' \leftarrow \con{\varphi'_c}{ \{\ell_1,\ldots,\ell_n \} }{\sigma}$
    }

    \BlankLine
  
    \If{$\varphi$ is a unit with more than one child satisfying the pre-deletion unifiability property}{
      \Push $\varphi'$ onto \Units  \;
      \Add $\varphi$ to $D$ \;
    }
  }
  \BlankLine


  \tcp{Reintroduce units}
  $\psi^{\star} \leftarrow \psi'$ \;
  \While{\Units $\neq \varnothing$}{
    $\varphi' \leftarrow$ \Pop from \Units \;

    $\psi^{\star}_{\mathrm{next}} \leftarrow \con{\psi^{\star}}{}{}$ \;
    \While{$\Conclusion{\psi^{\star}_{\mathrm{next}}} \neq \psi^{\star} $}{
      $\psi^{\star} \leftarrow \psi^{\star}_{\mathrm{next}}$ \;
      $\psi^{\star}_{\mathrm{next}} \leftarrow \con{\psi^{\star}}{}{}$ \;
    }

    
    \lIf{$\psi^{\star} \odot \varphi'$ is well-defined}{
      $\psi^{\star} \leftarrow \psi^{\star} \odot \varphi'$ }

  }

  \lIf{$\Conclusion{\psi^{\star}} = \bot$}{\Return{$\psi^{\star}$}}
  \lElse{\Return{$\psi$}}

  \caption{{\SFOLowerUnits} (single traversal)}
  \label{algo:optSFOLU}
\end{algorithm}

