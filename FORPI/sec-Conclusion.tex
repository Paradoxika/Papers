\section{Conclusions and Future Work}\label{sec:conclusion}

The main contribution of this paper is the lifting of the propositional proof compression algorithm {\RPI} to the first-order case. As indicated in Section \ref{sec:Challenges}, the generalization is challenging, because unification instantiates literals and, consequently, a node may be regularizable even if its resolved literals are not syntactically equal to any safe literal. Therefore, unification must be taken into account when collecting safe literals and marking nodes for deletion.

We first evaluated the algorithm on all 308 real proofs that the \texttt{SPASS} theorem prover (with only standard resolution enabled) was capable of generating when executed on unsatisfiable TPTP problems without equality. Although the compression achieved by the first-order {\FORPI} algorithm was not as good as the compression achieved by the propositional {\RPI} algorithm on real proofs generated by SAT and SMT solvers \cite{LURPI}, this is due to the fact that the 308 proofs were too short (less than 32 resolutions) to contain a significant amount of irregularities. In contrast, the propositional proofs used in the evaluation of the propositional {\RPI} algorithm had thousands (and sometimes hundreds of thousands) of resolutions. 

Our second evaluation used larger, but randomly generated, proofs. The compression achieved by {\FORPI} in a short amount of time on this data set was compatible with our expectations and previous experience in the propositional level. The obtained results indicate that {\FORPI} is a promising compression technique to be reconsidered when first-order theorem provers become capable of producing larger proofs. Although we carefully selected generation probabilites in accordance with frequencies observed in real proofs, it is important to note that randomly generated proofs may still differ from real proofs in shape and may be more or less likely to contain irregularities exploitable by our algorithm. Resolution restrictions and refinements (e.g. ordered resolution \cite{Maslov1964,KowalskiHayes1969,OrderedRes}, hyper-resolution \cite{HyperResolution}, unit-resulting resolution \cite{UnitResultingResolution,Prover9Manual}) tend to result in longer chains of resolutions and, therefore, in proofs with a possibly larger height to length ratio. As the number of irregularities increases with height, such proofs could have a higher number of irregularities in relation to length.

In this paper, for the sake of simplicity, we considered a pure resolution calculus without restrictions, refinements or extensions. However, in practice, theorem provers do use restrictions and extensions. It is conceptually easy to adapt the algorithm described here to such variations of resolution. For instance, restricted forms of resolution (e.g. ordered resolution, hyper-resolution, unit-resulting resolution) can be simply regarded as (chains of) unrestricted resolutions for the purpose of proof compression. The compression process would break the chains and change the structure of the proof, but the compressed proof would still be a correct unrestricted resolution proof, albeit not necessarily satisfying the restrictions that the input proof satisfied. In the case of extensions for equality reasoning using paramodulation-like inferences, it might be necessary to apply the paramodulations to the corresponding safe literals. Another common extension of resolution is the splitting technique \cite{WeidenbachSplitting}. When splitting is used, each split sub-problem is solved by a separate refutation, and the compression algorithm described here could be applied to each refutation independently.





% These algorithms are very fast, and together they may simplify the proof considerably for a relatively quick time cost.

% {\RPI} performs best when the proofs are tall; {\FORPI} will likely perform similarly. However, the proofs in this data set are relatively short, and those compressed by {\GFOLU} first are even shorter. Thus, the performance of {\FORPI} is not surprising.

%{\FORPI} continues to support the idea of listing propositional proof compression algorithms to the first-order case. The experimental results discussed in the previous continue to be encouraging, and are consistent with trends observed in the propositional case. 

%\paragraph{Acknowledgments:}
