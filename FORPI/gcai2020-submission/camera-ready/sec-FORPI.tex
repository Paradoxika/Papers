\section{Implementation}
\label{sec:FORPI}


\IncMargin{0.5em}
\begin{algorithm}[bt]
\begin{scriptsize}
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\SetKwData{units}{unitsQueue}
\SetKwData{fixedUnits}{fixedUnitsQueue}

\Input{A first-order proof $\psi$}
\Output{A possibly less-irregular first-order proof $\psi'$}

\BlankLine

$\psi'$ $\la$ $\psi$\;
traverse $\psi'$ bottom-up and \ForEach{node $\eta$ in $\psi'$}{
   \If{$\eta$ is a resolvent node}{
     setSafeLiterals($\eta$) \;
     regularizeIfPossible($\eta$)
   }
  }
$\psi'$ $\la$ fix($\psi'$) \;
\Return {$\psi'$}\;
\caption{\label{algo:FORPI} \texttt{\FORPI}.}
\end{scriptsize}
\end{algorithm}
\DecMargin{0.5em} 


\IncMargin{0.5em}
\begin{algorithm}[bt]
\begin{scriptsize}


\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\SetKwData{units}{unitsQueue}
\SetKwData{fixedUnits}{fixedUnitsQueue}

\Input{A first-order resolution node $\psi$}
\Output{nothing (but the node $\psi$ gets a set of safe literals)}

\BlankLine

    \lIf{$\psi$ is a root node with no children}{ $\mathcal{S}(\psi) \la$ $\psi$.clause    }
    \Else{
      \ForEach{$\psi'$ $\in$ $\psi${\upshape.children}}{
        \lIf{$\psi'$ is marked as regularized}{ 
          safeLiteralsFrom($\psi'$) $\la$ $\mathcal{S}(\psi')$ }
%        \uElseIf{$\eta$ is left parent of $\eta'$}{ 
          \lElseIf{$\psi' = \psi  \res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R} \psi_R$ for some $\psi_R$}{ 
        	safeLiteralsFrom($\psi'$) $\la$ $\mathcal{S}(\psi')~ \cup $ $\{\ell_R\sigma_R \}$ %\;
        }
        \lElseIf{$\psi' = \psi_L  \res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R} \psi$ for some $\psi_L$}{ 
	safeLiteralsFrom($\psi'$) $\la$ $\mathcal{S}(\psi') ~\cup $ $\{ \ell_L\sigma_L \}$%\;
        }
      }
      $\mathcal{S}(\psi)$ $\la$ $\bigcap_{\psi' \in \psi\textrm{.children}}$ safeLiteralsFrom($\psi'$)
    }

\caption{\label{algo:foSetSafeLiterals} \texttt{setSafeLiterals} for \texttt{FORPI}.}
\end{scriptsize}
\end{algorithm}
\DecMargin{0.5em}   

{\FirstOrderRPI} ({\FORPI}) (cf. Algorithm \ref{algo:FORPI}) is a first-order generalization of the propositional {\RPI}.
{\FORPI} traverses the proof in a bottom-up manner, storing for every node a set of safe literals. 
For a node $\psi$, $\mathcal{S}(\psi)$ is computed from the set of safe literals of its children (cf.\ Algorithm~\ref{algo:foSetSafeLiterals}), similarly to the propositional case, but additionally applying unifiers to the resolved literals.
If one of $\eta$'s resolved literals matches a literal in $\mathcal{S}(\eta)$, then it may be possible to regularize $\eta$ by replacing it by one of its parents.  






In the first-order case, we additionally check for strong regularizability (cf. lines 2 and 6 of Algorithm~\ref{algo:foRegularize}).
Similarly to {\RPI}, instead of replacing the irregular node by one of its parents immediately, 
its other parent is marked as a \texttt{deletedNode}, as shown in Algorithm~\ref{algo:foRegularize}.
As in the propositional case, fixing of the proof is postponed to another (single) traversal, as regularization proceeds top-down and only nodes below a regularized node may require fixing.
During fixing, the irregular node is actually replaced by the parent that is not marked as \texttt{deletedNode}. During proof fixing, factoring inferences can be applied, in order to compress the proof further.

\IncMargin{0.5em}
\begin{algorithm}[bt]
\begin{scriptsize}

\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\SetKwData{units}{unitsQueue}
\SetKwData{fixedUnits}{fixedUnitsQueue}

\Input{A node $\psi=\psi_L  \res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R} \psi_R$}
\Output{nothing (but the proof containing $\psi$ may be changed)}

\BlankLine
    \uIf{$\exists \sigma$  and $\ell \in \mathcal{S}(\psi)$ such that $\ell = \ell_R\sigma_R\sigma$}{
     %\uIf{$\exists \sigma'$ such that $\psi_R\sigma' \subseteq \mathcal{S}(\psi)$} {
     \uIf{$\psi_R\sigma_R\sigma \subseteq \mathcal{S}(\psi)$} {
      mark $\psi_L$ as \texttt{deletedNode} \;
      mark $\psi$ as regularized
}
    }
    \ElseIf{$\exists \sigma$  and $\ell \in \mathcal{S}(\psi)$ such that $\ell = \ell_L\sigma_L\sigma$ }{
    % \uIf{$\exists \sigma'$ such that $\psi_L\sigma' \subseteq\mathcal{S}(\psi)$} {
     \uIf{$\psi_L\sigma_L\sigma \subseteq\mathcal{S}(\psi)$} {
      mark $\psi_R$ as \texttt{deletedNode} \;
      mark $\psi$ as regularized
}
    }
\caption{\label{algo:foRegularize} \texttt{regularizeIfPossible} for \texttt{FORPI}.}
\end{scriptsize}
\end{algorithm}
\DecMargin{0.5em}    

    





