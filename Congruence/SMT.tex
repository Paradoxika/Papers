\documentclass{easychair}

\title{A note on conflict set generation\\ for congruence closure\\\small Extended abstract}
\titlerunning{A note on congruence closure}

\author{Andreas Fellner\inst{1,2}
   \and Pascal Fontaine\inst{4}
   \and\\ Georg Hofferek\inst{5}
   \and Bruno Woltzenlogel Paleo\inst{2,3}
}
\institute{IST-Austria, Klosterneuburg (Austria)
\and Vienna University of Technology (Austria)
\and Australian National University and NICTA (Australia)
\and Inria, Loria, U. of Lorraine (France)
\and IAIK, Graz University of Technology (Austria)}

\authorrunning{Fellner et al.}

\usepackage{amssymb}
\usepackage{graphicx}            			% Figures
\usepackage{tikz}					% tikz graphics
\usetikzlibrary{arrows,automata,positioning}
\usetikzlibrary{fit}
%\usepackage{hyperref}

\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\begin{document}

\maketitle

\begin{abstract}
The efficiency of Satisfiability Modulo Theories (SMT) solvers is dependent on
the capability of theory reasoners to provide small conflict sets, i.e.\ small
unsatisfiable subsets from unsatisfiable sets of literals.  Decision procedures
for uninterpreted symbols (i.e.\ congruence closure algorithms) date back from
the very early days of SMT.  Nevertheless, to our best knowledge, the complexity
of the smallest conflict set generation for sets of literals with uninterpreted
symbols and equalities had not yet been determined, although it is believed to
be NP-complete.  We provide here an NP-hardness proof, using a simple reduction
from SAT.
\end{abstract}


\section*{Introduction}

Satisfiability Modulo Theory solvers are nowadays based on a cooperation of a
propositional satisfiability (SAT) solver and a theory reasoner for the
combination of theories understood by the SMT solver. The propositional
structure of the problem is handled by the SAT solver, whereas the theory
reasoner only has to deal with conjunctions of literals.  Very schematically (we
refer to~\cite{Barrett14} for more details) the Boolean abstraction of the SMT
problem is repeatedly refined by adding theory conflict clauses that eliminate
spurious models of the abstraction, until either unsatisfiability is reached, or
a model of the SMT formula is found.  Refinements can be done by refuting models
of the propositional abstraction one at a time.  It is, however, much more
productive to refute all propositional models that are spurious for the same
reason.  A model of the abstraction is spurious if the set of concrete literals
corresponding to the abstracted literals satisfied by this model is
unsatisfiable.  Given such an unsatisfiable set of concrete literals, the
disjunction of the negations of any of its unsatisfiable core is a suitable
conflict clause.  By backtracking and asserting the conflict clause, the
SAT-solver is prevented from generating the spurious model again. The smaller
the clause, the stronger it is and the more spurious models it prevents.
Therefore, an optimal conflict clause, corresponding to a minimal unsatisfiable
subset of literals (i.e.\ such that all its proper subsets are satisfiable) or
even a minimum one (i.e.\ smallest among the minimals) is desirable.  This
feature of the theory reasoners to ``generate small conflict sets'' (a name
adopted in~\cite{Barrett14}) from their input is also called proof
production~\cite{Nieuwenhuis3,Nieuwenhuis9} or explanation
generation~\cite{Nieuwenhuis6}.\footnote{Proof production and explanation
  generation however convey the idea that, further than just giving a small
  unsatisfiable subset, the valuable reasoning process can be isolated from the
  unuseful computation.}

Decision procedures for the theory of uninterpreted symbols and equality can be
based on congruence closure~\cite{Nelson2,Downey1,Nieuwenhuis6}.  The decision problem is polynomial
and even quasilinear~\cite{Downey1} with respect the number of terms and
literals in the input set.  Producing minimal conflict sets also takes
polynomial time.  Indeed, testing if a set $S$ remains unsatisfiable after
removal of one of its literal is also polynomial.  It suffices then to
repeatedly test the $|S|$ literals of $S$ to check if they can be removed.  The
set $S$ pruned of its unnecessary literals is minimal.  One can also make profit of the incrementality of the decision procedure~\cite{Fontaine1}.

It has also been common knowledge that computing minimum conflict clauses for
the theory of uninterpreted symbols and equality is a difficult problem.  But,
to our best knowledge, the complexity of the smallest conflict clause generation
for sets of literals with uninterpreted symbols and equalities has never been
established.  It is mentioned to be NP-complete in~\cite{Nieuwenhuis8} --- with
a reference to a private communication with Ashish Tiwari --- but neither the
authors of~\cite{Nieuwenhuis8} nor Ashish Tiwari published a written proof of
this fact\footnote{We contacted both Ashish Tiwari and the authors
  of~\cite{Nieuwenhuis8} who confirmed this.}.

Our interest in this problem arose from our work on Skeptik \cite{Boudou1}, a tool for the compression of proofs generated by SAT and SMT solvers. For the sake of moving beyond the purely propositional level, we have developed an algorithm for compressing congruence closure proofs, which consists of regenerating (possibly smaller) congruence closure conflict clauses while traversing the proof. Congruence closure conflict clauses are typically generated from paths in the \emph{congruence graph} maintained by the congruence closure algorithm \cite{Fontaine2004,Nieuwenhuis6,Nieuwenhuis9}. During the replay, we use a polynomial-time algorithm for searching for short paths in the congruence graph, which is a modification of Dijkstra's shortest path algorithm \cite{Dijkstra1959}. This raised the question whether our algorithm could find the shortest conflict clauses, as Dijkstra's algorithm finds shortest paths. We answered this question negatively by proving that the problem of deciding whether a short conflict clause is NP-hard. The goal of this short note is to present this proof.



\section*{Notations}

Propositional logic and quantifier-free first order logic with equality

$S \models s=t$

A literal is either a Boolean variable or the negation of a Boolean variable.
A clause is a (disjunctive) set of literals.  A variable appears positively (negatively) in a clause if it (resp.\ its negation) belongs to the clause.

\section*{Congruence closure}

Original congruence closure algorithm~\cite{}

Explanation producing algorithms~\cite{}

Define ``explanation".



\section*{NP-completeness of small explanation decision problem}
\label{sec:npcomplete}

In Section \ref{sec:congruencedef} the notion of explanation is
defined and it is mentioned that we want to find short explanations
in order to compress proofs. In this section we show that the problem
of deciding whether there is an explanation of a given size is NP-
complete, and therefore finding short explanations is hard. Our proof
of NP-completeness reduces the problem of deciding the satisfiability
of a propositional logic formula in conjunctive normal form (SAT) to
the short explanation problem. For basics about satisfiability of
propositional logic formulas and assignments, we refer the reader to
\cite{Biere3}. We begin by formally defining the problem.


\begin{definition}[Short explanation problem]
Let $E = \{ s_1 = t_1,\ldots, s_n = t_n\}$ be a set of equations, 
$k \in \mathbb{N}$ and $s = t$ be a target equation.  
The \emph{short explanation problem} is the problem of finding 
whether there exists a set $E'$ such that $E' \subseteq E$, 
$E' \models s = t$ and $|E'| \leq k$.
\end{definition}

\noindent Our proof of hardness is based on a (polynomial) 
translation of the propositional satisfiability problem to 
the short explanation decision problem.

\newcommand{\Assignment}{{\it Assignment}}
\newcommand{\Clause}{{\it Clause}}
\newcommand{\Connect}{{\it Connect}}

\begin{definition}[CNF congruence translation]

Let $\mathcal{C}$ be a set of propositional clauses $\{C_1,\ldots C_n\}$ using variables $x_1,\ldots,x_m$.
%The set of terms $\mathcal{T}$ is constructed using the following constants and function symbols.
%For every $i= 1,\ldots,n + 1$, there is a constant $\hat{c}_i$ and function symbols $t_i$ and $f_i$.
%For every $j= 1,\ldots,m$, there are constants $\hat{x}_j$, $\top_j$ and $\bot_j$.
The congruence translation $E_{\mathcal{C}}$ of $\mathcal{C}$ is defined as the set of equations
\begin{equation*}
\Connect \cup \bigcup_{1 \leq i \leq n}\Clause_i 
\end{equation*}
with
\begin{eqnarray*}
	\Connect &=& \{ \hat{c}_{i}' = \hat{c}_{i+1} \mid 1 \leq i < n\}\\
        \Clause_i &=& \{ \hat{c}_i = t_i(\hat{x}_j) \mid x_j \text{ appears in } C_i \}\\
           & & \cup\ \{ t_i(\top_j) = \hat{c}_i' \mid x_j \text{ appears positively in } C_i \}\\
           & & \cup\ \{ t_i(\bot_j) = \hat{c}_i' \mid x_j \text{ appears negatively in } C_i \}
\end{eqnarray*}
where $\hat{c}_{1},\dots \hat{c}_{n},\hat{c}_{1}', \dots \hat{c}_{n}',
\hat{x}_1, \dots \hat{x}_m, \top_1, \dots \top_m, \bot_1, \dots \bot_m$ are distinct constants, and $t_1, \dots t_m$ are
distinct unary functions.

\end{definition}

\noindent This translation is illustrated by the following example.
% and a subset of the translation corresponding to a satisfying assignment.
%We use the standard notion of satisfiability and present variable assignments as sets of those propositional variables being mapped to true.

\begin{example}\label{ex:np1}
Consider the set of clauses $\mathcal{C}$
\begin{equation*}
\big\{C_1 = x_1 \vee x_2 \vee \neg x_3, C_2 = \neg x_2 \vee x_3, C_3 = \neg x_1 \vee \neg x_2\big\}.
\end{equation*}
Figure~\ref{fig:npexamplebig} represents $\Connect \cup \bigcup_{1 \leq i \leq n}\Clause_i$
graphically --- an edge between two nodes meaning that the set contains an
equation between the two nodes --- for the congruence translation $E_{\mathcal{C}}$ of
$\mathcal{C}$.

\begin{figure}[ht]
\input{figures/npexamplebig2}
\caption{$\Connect \cup \bigcup_{1 \leq i \leq n}\Clause_i$}
\label{fig:npexamplebig}
\end{figure}

\end{example}

Assignments can also be translated to sets of equations:
\begin{definition}[Assignment congruence translation]
Let $\mathcal{I}$ be an assignment on variables $x_1,\ldots,x_m$.
%The set of terms $\mathcal{T}$ is constructed using the following constants and function symbols.
%For every $i= 1,\ldots,n + 1$, there is a constant $\hat{c}_i$ and function symbols $t_i$ and $f_i$.
%For every $j= 1,\ldots,m$, there are constants $\hat{x}_j$, $\top_j$ and $\bot_j$.
The congruence translation $E_{\mathcal{I}}$ of $\mathcal{I}$ is defined as the set of equations
\begin{eqnarray*}
  E_{\mathcal{I}} & = & \phantom{\cup}\ \{ \hat{x}_j = \top_j \mid 1 \leq j \leq m \text{ and } \mathcal{I} \models x_j \} \\
               &   & \cup\ \{ \hat{x}_j = \bot_j \mid 1 \leq j \leq m \text{ and } \mathcal{I} \models \neg x_j \}
\end{eqnarray*}
For convenience, we also define the set
\begin{equation*}
  \Assignment^\star = \{ \hat{x}_j = \top_j, \hat{x}_j = \bot_j \mid 1 \leq j \leq m\}.
\end{equation*}
\end{definition}
\noindent
The congruence translation of an assigment is always a subset of
$\Assignment^\star$.  By abuse of language, a subset of $\Assignment^\star$ is
said to be an assignment if it is the congruence translation of an assignment,
that is, if it does not contain both $\hat{x}_j = \top_j$ and $\hat{x}_j =
\bot_j$ for some $j$.

\begin{example}\label{ex:np2} (Example~\ref{ex:np1} continued)  
Consider the model $\mathcal{I} = \{x_1, \neg x_2, x_3\}$ of $\mathcal{C}$.
Figure~\ref{fig:npassignment} gives a graphical representation of
$E_{\mathcal{I}}$, whereas $\Assignment^\star$ is described by
Figure~\ref{fig:npassignmentstar}.  Notice that
$E_{\mathcal{C}} \cup E_{\mathcal{I}} \models \hat{c}_1 = \hat{c}'_3$,
and $\hat{c}_1$ and $\hat{c}'_3$ are connected in the congruence graph\marginpar{congruence graph: define}
of $E_{\mathcal{C}} \cup E_{\mathcal{I}}$ (Figure~\ref{fig:npmodel}).
This is actually the aim of the construction.

\begin{figure}[ht]
\input{figures/npassignment2}
\caption{Congruence translation of $\mathcal{I}$}
\label{fig:npassignment}
\end{figure}

\begin{figure}[ht]
\input{figures/npassignmentstar2}
\caption{$\Assignment^\star$}
\label{fig:npassignmentstar}
\end{figure}
\begin{figure}[ht]
\input{figures/npmodel2}
\caption{The congruence graph for $E_{\mathcal{C}} \cup E_{\mathcal{I}}$}
\label{fig:npmodel}
\end{figure}
\end{example}

\begin{lemma}
\label{lemma:eqv}
Consider a (partial or total) assignment $\mathcal{I}$ for a set of clauses
$\mathcal{C}= \{C_1, \dots C_n\}$.  $\mathcal{I} \models \mathcal{C}$ if and only if
$E_{\mathcal{I}} \cup E_\mathcal{C} \models \hat{c}_1 = \hat{c}'_n$.
\end{lemma}
\begin{proof}
The condition is sufficient.  Consider the congruence graph induced by
$E_{\mathcal{I}} \cup E_\mathcal{C}$.  Besides edges directly associated to
equalities in the set, the only edges are congruence edges between terms
$t_i(\hat{x}_j)$ and either $t_i(\top_j)$ or $t_i(\bot_j)$.  So any path from
$\hat{c}_1$ to $\hat{c}_n$ would go through such a congruence edge for each $i$.
And such an edge exist for $i$ if and only if clause $i$ is satisfied by
$\mathcal{I}$.

The condition is also necessary.  If $\mathcal{I} \models \mathcal{C}$, then
$\mathcal{I} \models C_i$ for each clause $C_i \in \mathcal{C}$.  Assume
$\mathcal{I}$ makes true a variable $x_j$, literal of $C_i$ (the case of
negation of a variable is handled similarly).  Then $E_{\mathcal{I}} \models
t_i(\hat{x}_j) = t_i(\top_j)$, and $E_{\mathcal{I}} \cup \Clause_i
\models \hat{c}_i = \hat{c}_i'$.  This is true for each $i$, and
thanks to the equations in \Connect, one can deduce using transitivity that
$E_{\mathcal{I}} \cup E_\mathcal{C} \models \hat{c}_1 = \hat{c}_n'$.
\end{proof}

\noindent Notice also that, for any model $\mathcal{I}$ of a set of $n$ clauses
$\mathcal{C}$, every explanation that $E_{\mathcal{I}} \cup E_\mathcal{C}
\models \hat{c}_1 = \hat{c}_n'$ contains at least two equalities in
each set $\Clause_i$, since each clause has to be satisfied.  But also, there is
an explanation that contains exactly two equalities in each set $\Clause_i$.
Considering again Example~\ref{ex:np2}, and particularly
Figure~\ref{fig:npmodel}, any transitivity chain from $\hat{c}_1$ to
$\hat{c}'_3$ will pass through $\hat{c}'_1$, $\hat{c}_2$, $\hat{c}_2'$ and
$\hat{c}_3$.  Any acyclic path from $\hat{c}_1$ to $\hat{c}'_3$ will contain 11
edges: 3 congruence edges, $3\times 2$ edges in $\Clause_i$ for $i=1,\dots 3$
and 2 edges from $\Connect$.

Since every interpretation $\mathcal{I}$ is such that $E_{\mathcal{I}} \subset
\Assignment^\star$, one can try to relate the propositional satisfiability
problem for a set of clauses $\mathcal{C}= \{C_1, \dots C_n\}$ to finding an
explanation of $\hat{c}_1 = \hat{c}_n'$ in $\Assignment^\star \cup
E_{\mathcal{C}}$.  However, it is necessary that this explanation does not set
$\hat{x}_j$ equal both to $\top_j$ and $\bot_j$, i.e.\ at most one of the two
equations $(\hat{x}_j,\top_j)$ and $(\hat{x}_j,\bot_j)$ should be in the
explanation.  By restricting assignments to total ones, i.e.\ by enforcing that
at least one of the two equations $(\hat{x}_j,\top_j)$ and $(\hat{x}_j,\bot_j)$
belongs to the explanation, it is also possible, with a single cardinality
constraint on the explanation, to require that at most one of them belong to the
explanation.

\marginpar{Bruno: There seems to be redundancy between the informal paragraph above and the formal proof below. The paragraph seems more formal and detailed than necessary, while the proof perhaps less detailed than necessary.}

\begin{lemma}
A set of clauses $\mathcal{C}= \{C_1, \dots C_n\}$ using variables $x_1,\dots
x_m$ is satisfiable if and only if there is a subset $E' \subseteq
\Assignment^\star \cup E_{\mathcal{C}'}$ such that $E'\models \hat{c}_1 =
\hat{c}'_{n+m}$ and $|E'| \leq 3n+4m-1$, where $\mathcal{C}'$ is $\mathcal{C}$
augmented with the tautological clauses $c_{n+i} = x_i \vee \neg x_i$ for
$i=1,\dots m$.
\end{lemma}
\begin{proof}
The condition is straightforwardly necessary.  It is also sufficient since an
explanation of $\hat{c}_1 = \hat{c}'_{n+m}$ has to contain $2(n + m)$
equations from $Clause_i$ ($i= 1\dots n + m$) and $n + m - 1$ equations from
$\Connect$.  Thanks to the tautological clauses, any explanation also has to
contain at least $(\hat{x}_j,\top_j)$ or $(\hat{x}_j,\bot_j)$ for each
$j\in\{1\dots m\}$. Therefore, the cardinality constraint requires that the explanation
contains at most one $(\hat{x}_j,\top_j)$ or $(\hat{x}_j,\bot_j)$ for each
$j\in\{1\dots m\}$.  If such an explanation exists, Lemma~\ref{lemma:eqv}
guarantees the existence of a model for $\mathcal{C'}$, or equivalently for
$\mathcal{C}$.
\end{proof}




\begin{corollary}[NP-hardness]
\label{lemma:nphardness}
The short explanation decision problem is NP-hard.
\end{corollary}
\begin{proof}
Propositional satisfiability is NP-hard, and can be reduced in polynomial time
to the short explanation decision problem.
\end{proof}

\begin{lemma}[NP]
\label{lemma:innp}
The short explanation decision problem is in NP.
\end{lemma}
\begin{proof}
Explanations are subsets of the input equations, therefore they are clearly
polynomial in the problem size.  The congruence of two terms, i.e.\ verifying
that a subset is actually an explanation, can be decided in polynomial
time\marginpar{be more precise}\marginpar{bruno:citation needed?} using classical congruence closure algorithms.
\end{proof}

Lemmas~\ref{lemma:nphardness} and~\ref{lemma:innp} thus establish:

\begin{theorem}[NP-completeness]
The short explanation decision problem is NP-complete.
\end{theorem}

\section*{Conclusion}

Besson PxTP

We would like to thank Roberto Nieuwenhuis and Ashish Tiwari for the discussion
and some preliminary ideas that led us to this proof.

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}
